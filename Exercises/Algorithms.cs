using System.Text;

namespace Exercises;

public static class Algorithms
{
    public static int MakeAnagram(string a, string b)
    {
        /*
         * A student is taking a cryptography class and has found anagrams to be very useful.
         * Two strings are anagrams of each other if the first string's letters can be rearranged to form the second string.
         * In other words, both strings must contain the same exact letters in the same exact frequency.
         * For example, bacdc and dcbac are anagrams, but bacdc and dcbad are not.
         *
         * The student decides on an encryption scheme that involves two large strings.
         * The encryption is dependent on the minimum number of character deletions required to make the two strings anagrams.
         * Determine this number.
         * Given two strings,  and , that may or may not be of the same length, determine the minimum number of character deletions required to make  and  anagrams.
         * Any characters can be deleted from either of the strings.
         */

        var arr = new int[26];

        foreach (var l in a)
        {
            arr[l - 'a'] += 1;
        }

        foreach (var l in b)
        {
            arr[l - 'a'] -= 1;
        }

        return arr.Sum(Math.Abs);
    }

    public static char FindTheDifference(string s, string t)
    {
        /*
         * Given 2 strings s and t, string t is generated by random shuffling string s and then adding one more letter
         * at a random position. Return the letter that was added to t.
         *
         * For example,
         *
         * Input: s = "abc", t = "acba"
         * Output: "a"
         *
         * Input: s = "", t = "a"
         * Output: "a"
         *
         */

        var count = 0;

        for (var i = 0; i < s.Length; i++)
        {
            count -= s[i];

            count += t[i];
        }

        // Because t is longer than s by 1 character, we need to sum the last character
        // t[^1] is the same as t[t.Length - 1]
        // See C# 8 ranges operators here https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/ranges 
        count += t[^1];

        // The final count should be equals to the letter in ASCII code
        return (char)count;
    }

    public static int AlternatingCharacters(string s)
    {
        /*
         * You are given a string containing characters  and  only.
         * Your task is to change it into a string such that there are no matching adjacent characters.
         * To do this, you are allowed to delete zero or more characters in the string.
         * Your task is to find the minimum number of required deletions.
         *
         * Example
         * s = AABAAB
         * Remove an A at positions 0 and 3 to make s = ABAB in 2 deletions.
         *
         */

        var deletions = 0;

        for (var i = 1; i < s.Length; i++)
        {
            if (s[i] == s[i - 1])
                deletions++;
        }

        return deletions;
    }

    public static string IsValidSherlockString(string s)
    {
        var counts = new int[26];

        // Count character frequencies
        foreach (var l in s)
            counts[l - 'a']++;

        // Filter out characters that didn't appeared (count = 0)
        var filteredCounts = counts
            .Where(e => e > 0)
            .ToArray();

        // This means the string contains the same character, which is a valid case
        if (filteredCounts.Length <= 1)
            return "YES";

        // Sort has O(N * log N) time complexity
        Array.Sort(filteredCounts);

        var first = filteredCounts[0];
        var second = filteredCounts[1];
        var penultimate = filteredCounts[^2]; // using "hat" operator: index from end
        var last = filteredCounts[^1];

        // All frequencies are equals
        if (first == last)
            return "YES";

        // Character with frequency = 1 can be removed
        if (first == 1
            && second == last)
            return "YES";

        // One character with frequency = last can be removed
        if (first == second
            && second == penultimate
            && (last - penultimate) == 1)
            return "YES";

        return "NO";
    }
    public static long SubstringCount(int n, string s)
    {
        if (n == 1)
            return n;

        // Each individual character counts 
        var count = n;

        // Time complexity: O(N^2)
        // Solution works however is not the most efficient one
        for (var i = 0; i < n - 1; i++)
        {
            for (var j = 1; j < n - i; j++)
            {
                var substring = s.Substring(i, j + 1);

                if (substring.Distinct().Count() == 1)
                {
                    count++;
                }
                else if (substring.Length == 3)
                {
                    var first = substring[0];
                    var third = substring[2];

                    if (first == third)
                        count++;

                    break;
                }
            }
        }

        return count;
    }

    public static int FlippingMatrix(List<List<int>> matrix)
    {
        /*
         * Sean invented a game involving a  matrix where each cell of the matrix contains an integer.
         * He can reverse any of its rows or columns any number of times.
         * The goal of the game is to maximize the sum of the elements in the submatrix located in the upper-left quadrant of the matrix.
         * Given the initial configurations for  matrices, help Sean reverse the rows and columns of each matrix in the best possible way so that the sum of the elements in the matrix's upper-left quadrant is maximal.
         *
         * Example 1
         * 1 2      =>      4 2 
         * 3 4              1 3
         * Result: 4
         *
         * Example 2
         * 112 42 83 119            119 114 42  112 
         * 56 125 56 49     =>      56  125 101 49
         * 15 78 101 43             15  78  56  43
         * 62 98 114 108            62  98  83  108
         *
         * Result: 119 + 114 + 56 + 125 414
         * 
         */

        /*
         * The pattern that solves this problem is the following one:
         *
         * A) Matrix 2x2 (n = 1)
         *    a a
         *    a a
         *
         *    MaxSum = Max(a)
         *
         * B) Matrix 4x4 (n = 2)
         *    a b b a
         *    c d d c
         *    c d d c
         *    a b b a
         *
         *    MaxSum = Max(a) + Max(b) + Max(c) + Max(d)
         *
         * C) Matrix 6x6 (n = 3)
         *    a b c c b a
         *    d e f f e d
         *    g h i i h g
         *    g h i i h g
         *    d e f f e d
         *    a b c c b a
         *
         *    MaxSum = Max(a) + Max(b) + Max(c) + Max(d) + Max(e) + Max(f) + Max(g) + Max(h) + Max(i)
         *
         */

        var maxSum = 0;
        var n = matrix.Count / 2;

        for (var i = 0; i < n; i++)
        {
            for (var j = 0; j < n; j++)
            {
                var max = 0;

                max = Math.Max(matrix[i][j], max);
                max = Math.Max(matrix[i][n * 2 - j - 1], max);
                max = Math.Max(matrix[n * 2 - i - 1][j], max);
                max = Math.Max(matrix[n * 2 - i - 1][n * 2 - j - 1], max);

                maxSum += max;
            }
        }

        return maxSum;
    }

    public static string MinimumBribes(List<int> q)
    {
        /*
         * It is New Year's Day and people are in line for the Wonderland rollercoaster ride.
         * Each person wears a sticker indicating their initial position in the queue from 1 to N.
         * Any person can bribe the person directly in front of them to swap positions, but they still wear their original sticker.
         * One person can bribe at most two others.
         * Determine the minimum number of bribes that took place to get to a given queue order.
         * Return string with the number of bribes, or, if anyone has bribed more than two people, return 'Too chaotic'.
         *
         * Example 1:
         * q = [2, 1, 5, 3, 4]
         * Output: 3
         *
         * Example 2:
         * q = [2, 5, 1, 3, 4]
         * Output: Too chaotic
         *
         */

        var bribesCount = 0;

        for (var i = 0; i < q.Count; i++)
        {
            var pos = i + 1;

            // Compare sticker value with current position to know if anyone has bribed more than 2 people
            if (q[i] - pos > 2)
            {
                return "Too chaotic";
            }

            // Given a person is not allowed to bribe more than twice, then avoid checking
            // every single value and narrow down loop iterations by doing j = Math.Max(0, q[i] - 2)
            // Credits to Dennis Wang and his blog for this improvement (https://medium.com/@dwang0816/new-year-chaos-41e8e56cb342)
            for (var j = Math.Max(0, q[i] - 2); j < i; j++)
            {
                if (q[j] > q[i])
                {
                    bribesCount++;
                }
            }
        }

        return bribesCount.ToString();
    }

    public static string OrderSizes(string T)
    {
        var smalls = new StringBuilder();
        var mediums = new StringBuilder();
        var larges = new StringBuilder();

        foreach (var letter in T)
        {
            if (letter == 'S')
            {
                smalls.Append(letter);
            }
            else if (letter == 'M')
            {
                mediums.Append(letter);
            }
            else if (letter == 'L')
            {
                larges.Append(letter);
            }
        }

        return smalls
            .Append(mediums)
            .Append(larges)
            .ToString();
    }

    public static string SuperReducedString(string s)
    {
        if (s.Length == 1)
            return s;

        var result = RemoveDuplicates(s);

        return string.IsNullOrEmpty(result)
            ? "Empty String"
            : result;
    }

    public static string CaesarCipher(string s, int k)
    {
        /*
         * Julius Caesar protected his confidential information by encrypting it using a cipher.
         * Caesar's cipher shifts each letter by a number of letters. If the shift takes you past the end of the alphabet,
         * just rotate back to the front of the alphabet. In the case of a rotation by 3, w, x, y and z would map to z, a, b and c.
         *
         * Original alphabet:      abcdefghijklmnopqrstuvwxyz
         * Alphabet rotated +3:    defghijklmnopqrstuvwxyzabc
         *
         */
        var encryptedText = s.ToCharArray();

        if (k > 26)
        {
            k %= 26;
        }

        for (var i = 0; i < encryptedText.Length; i++)
        {
            if (!char.IsLetter(encryptedText[i]))
                continue;

            var letter = encryptedText[i] + k;

            if (char.IsUpper(encryptedText[i])
                && letter > 'Z')
            {
                letter = letter - 'Z' + 'A' - 1;
            }
            else if (char.IsLower(encryptedText[i])
                     && letter > 'z')
            {
                letter = letter - 'z' + 'a' - 1;
            }

            encryptedText[i] = (char)letter;
        }

        return new string(encryptedText);
    }

    public static int MinimumNumber(string password)
    {
        /*
         * Louise joined a social networking site to stay in touch with her friends.
         * The signup page required her to input a name and a password. However, the password must be strong.
         * The website considers a password to be strong if it satisfies the following criteria:
         * Its length is at least 6.
         * It contains at least one digit.
         * It contains at least one lowercase English character.
         * It contains at least one uppercase English character.
         * It contains at least one special character. The special characters are: !@#$%^&*()-+
         *
         * She typed a random string of length n in the password field but wasn't sure if it was strong.
         * Given the string she typed, can you find the minimum number of characters she must add to make her password strong?
         *
         * Example:
         * password = '2bb#A'
         * This password is 5 characters long and has at least one of each character type. The minimum number of characters to add is 1.
         *
         */
        const string specialCharacters = "!@#$%^&*()-+";

        var hasDigit = false;
        var hasLower = false;
        var hasUpper = false;
        var hasSpecial = false;

        for (var i = 0; i < password.Length; i++)
        {
            if (char.IsDigit(password[i]))
                hasDigit = true;

            if (char.IsLower(password[i]))
                hasLower = true;

            if (char.IsUpper(password[i]))
                hasUpper = true;

            if (specialCharacters.IndexOf(password[i]) != -1)
                hasSpecial = true;
        }

        var passedValidationsCount = Convert.ToInt32(hasDigit) +
                                     Convert.ToInt32(hasLower) +
                                     Convert.ToInt32(hasUpper) +
                                     Convert.ToInt32(hasSpecial);

        var missingValidationsCount = 4 - passedValidationsCount;
        var missingCharactersCount = 6 - password.Length;

        return Math.Max(missingValidationsCount, missingCharactersCount);
    }

    #region Codility

    public static int BinaryGap(int n)
    {
        /*
            Lesson #1 - https://app.codility.com/programmers/lessons/1-iterations/binary_gap/

            A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by 
            ones at both ends in the binary representation of N.
        */

        // Time complexity: O(N) 

        var binary = Convert.ToString(n, 2);

        var maxGap = 0;
        var gap = 0;

        var openningOne = false;

        for (var i = 0; i < binary.Length; i++)
        {
            var curr = binary[i];

            if (curr == '1')
            {
                if (openningOne)
                {
                    if (gap > maxGap)
                        maxGap = gap;

                    gap = 0;
                }
                else
                    openningOne = true;
            }
            else
            {
                gap++;
            }
        }

        return maxGap;
    }


    public static int[] RotateArray(int[] a, int k)
    {
        /*
            Lesson #2 - https://app.codility.com/programmers/lessons/2-arrays/cyclic_rotation/
            
            An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and 
            the last element of the array is moved to the first place. 
            For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] 
            (elements are shifted right by one index and 6 is moved to the first place).

            The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.


            k = 1
            Input  = [3, 8, 9, 7, 6] 
            Output = [6, 3, 8, 9, 7]

                0 <= N    <= 100  [0..100]
                0 <= K    <= 100  [0..100]
            -1000 <= A[i] <= 1000 [-1000..1000]
        */

        // Time complexity: O(N) 
        // Space complexity: O(N) 

        if (a.Length == 0)
            return a;

        if (k >= a.Length)
            k = k % a.Length;

        if (k == 0)
            return a;

        // Create an array of A length
        var result = new int[a.Length];

        // Loop over A
        for (var i = 0; i < a.Length; i++)
        {
            // Calculate new index
            var newIndex = i + k;

            if (newIndex >= a.Length)
                newIndex = newIndex % a.Length;

            result[newIndex] = a[i];
        }

        return result;
    }

    public static int OddOccurrencesInArraySolution1(int[] a)
    {
        /*
            Lesson #2 - https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/
            
            A non-empty array A consisting of N integers is given. The array contains an odd number of elements, 
            and each element of the array can be paired with another element that has the same value, 
            except for one element that is left unpaired.

            1 <= N <= 1,000,000
            1 <= A[i] <= 1,000,000,000

            all but one A[i] occur an even number of times 
        */

        // Time complexity: O(N) 
        // Space complexity: O(N) 

        if (a.Length == 1)
            return a[0];

        var result = 0;
        var counts = new Dictionary<int, int>();

        // Count the occurrence of each number
        for (var i = 0; i < a.Length; i++)
        {
            if (!counts.ContainsKey(a[i]))
                counts[a[i]] = 0;

            counts[a[i]]++;
        }

        // Find the number that occurs one time
        foreach (var key in counts.Keys)
        {
            if (counts[key] == 1)
            {
                result = key;
                break;
            }
        }

        return result;
    }

    public static int OddOccurrencesInArraySolution2(int[] a)
    {
        /*
            Lesson #2 - https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/

            Using XOR operator is one of the best solutions to solve the problem
            
            XOR operator:
                n XOR n = 0
                n XOR 0 = n

            So applying XOR operator to all array elements, will give us the number with single occurrence

            a = [1,2,3,3,2]
              = 1 ^ 2 ^ 3 ^ 3 ^ 2
              = 1 ^ (2 ^ 2) ^ (3 ^ 3)
              = 1 ^ 0 ^ 0
              = 1
        */

        // Time complexity: O(N) 
        // Space complexity: O(1) 

        if (a.Length == 1)
            return a[0];

        var result = a[0];

        for (var i = 1; i < a.Length; i++)
            result = result ^ a[i];

        return result;
    }

    public static int FrogJumps(int x, int y, int d)
    {
        /*
            Lesson #3 - https://app.codility.com/programmers/lessons/3-time_complexity/frog_jmp/

            A small frog wants to get to the other side of the road. The frog is currently located at position X and
            wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.

            Count the minimal number of jumps that the small frog must perform to reach its target.

            X = 10
            Y = 85
            D = 30

            Output = 3
        */

        // Time complexity: O(1)

        // Calculate Y - X and divide the result by D.
        // Then, use Ceiling to get the smallest integer >= to the calculated decimal value

        if (x == y)
            return 0;

        var jumps = (int)Math.Ceiling((decimal)(y - x) / d);

        return jumps;
    }

    public static int PermMissingElemSolution1(int[] a)
    {
        /*
            Lesson #3 - https://app.codility.com/programmers/lessons/3-time_complexity/perm_missing_elem/

            An array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], 
            which means that exactly one element is missing.

            Your goal is to find that missing element.

            0 <=  N   <= 100,000
            1 <= A[i] <= N+1
            A[i] != A[j]

            Examples:
                A = []      => 1
                A = [1]     => 2
                A = [2]     => 1
                A = [1,3,4] => 2
                A = [1,2,3] => 4
                A = [2,3,4] => 1
                A = [1,3]   => 1
        */

        // Time complexity: O(N * log(N))
        // See Solution #2 for a more efficient solution which is O(N)

        var result = 1;

        if (a.Length == 0)
            return result;

        if (a.Length == 1 && a[0] == 1)
            return result + 1;

        if (a.Length == 1 && a[0] == 2)
            return result;

        Array.Sort(a);

        for (var i = 0; i < a.Length; i++)
        {
            var curr = a[i];

            if (curr == i + 1)
            {
                result = curr + 1;
            }
            else
            {
                result = i + 1;
                break;
            }
        }

        return result;
    }

    public static int PermMissingElemSolution2(int[] a)
    {
        // Lesson #3 - https://app.codility.com/programmers/lessons/3-time_complexity/perm_missing_elem/

        // Time complexity: O(N)

        if (a.Length == 0)
            return 1;

        // Sum elements of array
        // Using LINQ you can do: var sum = a.Select(x => (long)x).Sum();
        // Parse to long to prevent overflow

        long sum = 0;

        for (var i = 0; i < a.Length; i++)
        {
            sum += (long)a[i];
        }

        // Sum of consecutive integers from 1 to N  = N * (N + 1) / 2
        long n = a.Length + 1;
        long totalSum = n * (n + 1) / 2;

        // The difference is the missing element
        return (int)(totalSum - sum);
    }

    public static int TapeEquilibrium(int[] a)
    {
        /*
            Lesson #3 - https://app.codility.com/programmers/lessons/3-time_complexity/tape_equilibrium/
            
            A non-empty array A consisting of N integers is given. Array A represents numbers on a tape.
            The difference between the two parts is the value of: |(A[0] + A[1] + ... + A[P − 1]) − (A[P] + A[P + 1] + ... + A[N − 1])|

            In other words, it is the absolute difference between the sum of the first part and the sum of the second part.
        
                0 <  P   < N
                2 <  N   < 100,000
            -1000 < A[i] < 1000

            Example:
            [3, 1, 2, 4, 3]

                [3]          - [1, 2, 4, 3] = 7
                [3, 1]       - [2, 4, 3]    = 5
                [3, 1, 2]    - [4, 3]       = 1
                [3, 1, 2, 4] - [3]          = 7

        */

        // Time complexity:  O(N)
        // Space complexity: O(N)

        // Create an array of 'A.Length - 1' length to hold the absolute differences
        var differences = new int[a.Length - 1];
        var firstSum = 0;
        var secondSum = 0;

        // Calculate sum for 1st part. Store values for each position.
        for (var i = 0; i < a.Length - 1; i++)
        {
            firstSum += a[i];

            differences[i] = firstSum;
        }

        // Calculate sum for 2nd part (from N - 1 to 1) and subtract it from the sum calculated in 1st part
        for (var j = a.Length - 1; j > 0; j--)
        {
            secondSum += a[j];

            differences[j - 1] = Math.Abs(differences[j - 1] - secondSum);
        }

        var minDiff = differences[0];

        // Get the min difference
        for (var k = 1; k < differences.Length; k++)
        {
            if (differences[k] < minDiff)
                minDiff = differences[k];
        }

        return minDiff;
    }

    public static int FrogRiverOne(int x, int[] a)
    {
        /*
            Lesson #4 - https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/

            A small frog wants to get to the other side of a river. 
            The frog is initially located on one bank of the river (position 0) and 
            wants to get to the opposite bank (position X+1). 
            Leaves fall from a tree onto the surface of the river.

            1 <= N, X <= 100,000
            1 <= A[i] <= X

            Example: 
                X = 5
                A = [1, 3, 1, 4, 2, 3, 5, 4]
                     0  1  2  3  4  5  6  7
                Output = 6
        */

        // Time complexity: O(N)
        // Space complexity: O(N)

        var minTime = -1;
        var leaves = new Dictionary<int, bool>();

        // Find minimum i where all elements in [1, X] occurs at least 1 time
        for (var i = 0; i < a.Length; i++)
        {
            if (a[i] <= x)
                leaves[a[i]] = true;

            if (leaves.Keys.Count == x)
            {
                minTime = i;
                break;
            }
        }

        return minTime;
    }

    public static int PermutationCheck(int[] a)
    {
        // Lesson #4 - https://app.codility.com/programmers/lessons/4-counting_elements/perm_check/

        // A = [1, 2, 3]    => Permutation
        // A = [1, 3]       => Not a permutation
        // A = [1, 4, 1]    => Not a permutation

        // Time complexity: O(N)
        // Space complexity: O(N)

        var elements = new Dictionary<int, bool>();

        for (var i = 0; i < a.Length; i++)
        {
            // Check case [1, 2, 2]
            if (elements.ContainsKey(a[i]))
                return 0; // Not a permutation

            // Check case [1, 2, 4]
            if (a[i] > a.Length)
                return 0; // Not a permutation

            elements[a[i]] = true;
        }

        // Case [1, 2, 3, 4]
        return 1; // Permutation
    }

    public static int PassingCars(int[] a)
    {
        // Lesson #5 - https://app.codility.com/programmers/lessons/5-prefix_sums/

        // 1 <= N <= 100,000

        // [0, 1, 0, 1, 1]
        //  E  W  E  W  W
        //    +1    +2 +2

        // Time complexity: O(N)

        var pairs = 0;
        var eastCount = 0;

        for (var i = 0; i < a.Length; i++)
        {
            if (a[i] == 0)
                eastCount++;

            if (a[i] == 1)
                pairs += eastCount;

            if (pairs > 1000000000)
                return -1;
        }

        return pairs;
    }

    public static int Distinct(int[] a)
    {
        // Lesson #6 - https://app.codility.com/programmers/lessons/6-sorting/distinct/

        // Time complexity: O(N)
        // Space complexity: O(N)

        var values = new Dictionary<int, bool>();

        foreach (var v in a)
            values[v] = true;

        return values.Count;
    }

    public static int Triangle(int[] a)
    {
        // Lesson #6 - https://app.codility.com/programmers/lessons/6-sorting/triangle/

        /*
            [.., ap, aq, ar, ..]

            Conditions:
                1) ap + aq > ar
                2) aq + ar > ap
                3) ar + ap > aq
         */

        // Time complexity: O(N * log N)
        // Space complexity: O(1)

        if (a.Length < 3)
            return 0;

        Array.Sort(a);

        for (var i = 0; i < a.Length - 2; i++)
        {
            // Use long to avoid arithmetic overflow error
            long ap = a[i];
            long aq = a[i + 1];
            long ar = a[i + 2];

            // Just check condition #1
            // Given values are sorted, conditions #2 and #3 are true
            if (ap + aq > ar)
                return 1;
        }

        return 0;
    }

    #endregion

    #region Private Method(s)

    private static string RemoveDuplicates(string s)
    {
        var text = s.ToCharArray();

        var updated = false;

        for (var i = 0; i < text.Length - 1; i++)
        {
            var curr = text[i];
            var next = text[i + 1];

            if (curr == next)
            {
                text[i] = ' ';
                text[i + 1] = ' ';

                updated = true;
            }
        }

        var result = new string(text).Replace(" ", string.Empty);

        return updated
            ? RemoveDuplicates(result)
            : result;
    }

    #endregion
}