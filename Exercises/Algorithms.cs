using System.Text;

namespace Exercises;

public static class Algorithms
{
    public static int MakeAnagram(string a, string b)
    {
        /*
         * A student is taking a cryptography class and has found anagrams to be very useful.
         * Two strings are anagrams of each other if the first string's letters can be rearranged to form the second string.
         * In other words, both strings must contain the same exact letters in the same exact frequency.
         * For example, bacdc and dcbac are anagrams, but bacdc and dcbad are not.
         *
         * The student decides on an encryption scheme that involves two large strings.
         * The encryption is dependent on the minimum number of character deletions required to make the two strings anagrams.
         * Determine this number.
         * Given two strings,  and , that may or may not be of the same length, determine the minimum number of character deletions required to make  and  anagrams.
         * Any characters can be deleted from either of the strings.
         */

        var arr = new int[26];

        foreach (var l in a)
        {
            arr[l - 'a'] += 1;
        }

        foreach (var l in b)
        {
            arr[l - 'a'] -= 1;
        }

        return arr.Sum(Math.Abs);
    }

    public static char FindTheDifference(string s, string t)
    {
        /*
         * Given 2 strings s and t, string t is generated by random shuffling string s and then adding one more letter
         * at a random position. Return the letter that was added to t.
         *
         * For example,
         *
         * Input: s = "abc", t = "acba"
         * Output: "a"
         *
         * Input: s = "", t = "a"
         * Output: "a"
         *
         */

        var count = 0;

        for (var i = 0; i < s.Length; i++)
        {
            count -= s[i];

            count += t[i];
        }

        // Because t is longer than s by 1 character, we need to sum the last character
        // t[^1] is the same as t[t.Length - 1]
        // See C# 8 ranges operators here https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/ranges 
        count += t[^1];

        // The final count should be equals to the letter in ASCII code
        return (char)count;
    }

    public static int AlternatingCharacters(string s)
    {
        /*
         * You are given a string containing characters  and  only.
         * Your task is to change it into a string such that there are no matching adjacent characters.
         * To do this, you are allowed to delete zero or more characters in the string.
         * Your task is to find the minimum number of required deletions.
         *
         * Example
         * s = AABAAB
         * Remove an A at positions 0 and 3 to make s = ABAB in 2 deletions.
         *
         */

        var deletions = 0;

        for (var i = 1; i < s.Length; i++)
        {
            if (s[i] == s[i - 1])
                deletions++;
        }

        return deletions;
    }

    public static string IsValidSherlockString(string s)
    {
        var counts = new int[26];

        // Count character frequencies
        foreach (var l in s)
            counts[l - 'a']++;

        // Filter out characters that didn't appeared (count = 0)
        var filteredCounts = counts
            .Where(e => e > 0)
            .ToArray();

        // This means the string contains the same character, which is a valid case
        if (filteredCounts.Length <= 1)
            return "YES";

        // Sort has O(n) time complexity
        Array.Sort(filteredCounts);

        var first = filteredCounts[0];
        var second = filteredCounts[1];
        var penultimate = filteredCounts[^2]; // using "hat" operator: index from end
        var last = filteredCounts[^1];

        // All frequencies are equals
        if (first == last)
            return "YES";

        // Character with frequency = 1 can be removed
        if (first == 1
            && second == last)
            return "YES";

        // One character with frequency = last can be removed
        if (first == second
            && second == penultimate
            && (last - penultimate) == 1)
            return "YES";

        return "NO";
    }

    public static long SubstringCount(int n, string s)
    {
        if (n == 1)
            return n;

        // Each individual character counts 
        var count = n;

        // Solution works however is not the most efficient one
        // This is O(N^2)
        for (var i = 0; i < n - 1; i++)
        {
            for (var j = 1; j < n - i; j++)
            {
                var substring = s.Substring(i, j + 1);

                if (substring.Distinct().Count() == 1)
                {
                    count++;
                }
                else if (substring.Length == 3)
                {
                    var first = substring[0];
                    var third = substring[2];

                    if (first == third)
                        count++;

                    break;
                }
            }
        }

        return count;
    }

    public static int FlippingMatrix(List<List<int>> matrix)
    {
        /*
         * Sean invented a game involving a  matrix where each cell of the matrix contains an integer.
         * He can reverse any of its rows or columns any number of times.
         * The goal of the game is to maximize the sum of the elements in the submatrix located in the upper-left quadrant of the matrix.
         * Given the initial configurations for  matrices, help Sean reverse the rows and columns of each matrix in the best possible way so that the sum of the elements in the matrix's upper-left quadrant is maximal.
         *
         * Example 1
         * 1 2      =>      4 2 
         * 3 4              1 3
         * Result: 4
         *
         * Example 2
         * 112 42 83 119            119 114 42  112 
         * 56 125 56 49     =>      56  125 101 49
         * 15 78 101 43             15  78  56  43
         * 62 98 114 108            62  98  83  108
         *
         * Result: 119 + 114 + 56 + 125 414
         * 
         */

        /*
         * The pattern that solves this problem is the following one:
         *
         * A) Matrix 2x2 (n = 1)
         *    a a
         *    a a
         *
         *    MaxSum = Max(a)
         *
         * B) Matrix 4x4 (n = 2)
         *    a b b a
         *    c d d c
         *    c d d c
         *    a b b a
         *
         *    MaxSum = Max(a) + Max(b) + Max(c) + Max(d)
         *
         * C) Matrix 6x6 (n = 3)
         *    a b c c b a
         *    d e f f e d
         *    g h i i h g
         *    g h i i h g
         *    d e f f e d
         *    a b c c b a
         *
         *    MaxSum = Max(a) + Max(b) + Max(c) + Max(d) + Max(e) + Max(f) + Max(g) + Max(h) + Max(i)
         *
         */

        var maxSum = 0;
        var n = matrix.Count / 2;

        for (var i = 0; i < n; i++)
        {
            for (var j = 0; j < n; j++)
            {
                var max = 0;

                max = Math.Max(matrix[i][j], max);
                max = Math.Max(matrix[i][n * 2 - j - 1], max);
                max = Math.Max(matrix[n * 2 - i - 1][j], max);
                max = Math.Max(matrix[n * 2 - i - 1][n * 2 - j - 1], max);

                maxSum += max;
            }
        }

        return maxSum;
    }

    public static string MinimumBribes(List<int> q)
    {
        /*
         * It is New Year's Day and people are in line for the Wonderland rollercoaster ride.
         * Each person wears a sticker indicating their initial position in the queue from 1 to N.
         * Any person can bribe the person directly in front of them to swap positions, but they still wear their original sticker.
         * One person can bribe at most two others.
         * Determine the minimum number of bribes that took place to get to a given queue order.
         * Return string with the number of bribes, or, if anyone has bribed more than two people, return 'Too chaotic'.
         *
         * Example 1:
         * q = [2, 1, 5, 3, 4]
         * Output: 3
         *
         * Example 2:
         * q = [2, 5, 1, 3, 4]
         * Output: Too chaotic
         *
         */

        var bribesCount = 0;

        for (var i = 0; i < q.Count; i++)
        {
            var pos = i + 1;

            // Compare sticker value with current position to know if anyone has bribed more than 2 people
            if (q[i] - pos > 2)
            {
                return "Too chaotic";
            }

            // Given a person is not allowed to bribe more than twice, then avoid checking
            // every single value and narrow down loop iterations by doing j = Math.Max(0, q[i] - 2)
            // Credits to Dennis Wang and his blog for this improvement (https://medium.com/@dwang0816/new-year-chaos-41e8e56cb342)
            for (var j = Math.Max(0, q[i] - 2); j < i; j++)
            {
                if (q[j] > q[i])
                {
                    bribesCount++;
                }
            }
        }

        return bribesCount.ToString();
    }

    public static string OrderSizes(string T)
    {
        var smalls = new StringBuilder();
        var mediums = new StringBuilder();
        var larges = new StringBuilder();

        foreach (var letter in T)
        {
            if (letter == 'S')
            {
                smalls.Append(letter);
            }
            else if (letter == 'M')
            {
                mediums.Append(letter);
            }
            else if (letter == 'L')
            {
                larges.Append(letter);
            }
        }

        return smalls
            .Append(mediums)
            .Append(larges)
            .ToString();
    }

    public static int BinaryGap(int n)
    {
        var binary = Convert.ToString(n, 2);

        var maxGap = 0;
        var gap = 0;

        var openningOne = false;

        for (var i = 0; i < binary.Length; i++)
        {
            var curr = binary[i];

            if (curr == '1')
            {
                if (openningOne)
                {
                    if (gap > maxGap)
                        maxGap = gap;

                    gap = 0;
                }
                else
                    openningOne = true;
            }
            else
            {
                gap++;
            }
        }

        return maxGap;
    }

    public static string SuperReducedString(string s)
    {
        if (s.Length == 1)
            return s;

        var result = RemoveDuplicates(s);

        return string.IsNullOrEmpty(result)
            ? "Empty String"
            : result;
    }

    public static string CaesarCipher(string s, int k)
    {
        /*
         * Julius Caesar protected his confidential information by encrypting it using a cipher.
         * Caesar's cipher shifts each letter by a number of letters. If the shift takes you past the end of the alphabet,
         * just rotate back to the front of the alphabet. In the case of a rotation by 3, w, x, y and z would map to z, a, b and c.
         *
         * Original alphabet:      abcdefghijklmnopqrstuvwxyz
         * Alphabet rotated +3:    defghijklmnopqrstuvwxyzabc
         *
         */
        var encryptedText = s.ToCharArray();

        if (k > 26)
        {
            k %= 26;
        }

        for (var i = 0; i < encryptedText.Length; i++)
        {
            if (!char.IsLetter(encryptedText[i]))
                continue;

            var letter = encryptedText[i] + k;

            if (char.IsUpper(encryptedText[i])
                && letter > 'Z')
            {
                letter = letter - 'Z' + 'A' - 1;
            }
            else if (char.IsLower(encryptedText[i])
                     && letter > 'z')
            {
                letter = letter - 'z' + 'a' - 1;
            }

            encryptedText[i] = (char)letter;
        }

        return new string(encryptedText);
    }

    public static int MinimumNumber(string password)
    {
        /*
         * Louise joined a social networking site to stay in touch with her friends.
         * The signup page required her to input a name and a password. However, the password must be strong.
         * The website considers a password to be strong if it satisfies the following criteria:
         * Its length is at least 6.
         * It contains at least one digit.
         * It contains at least one lowercase English character.
         * It contains at least one uppercase English character.
         * It contains at least one special character. The special characters are: !@#$%^&*()-+
         *
         * She typed a random string of length n in the password field but wasn't sure if it was strong.
         * Given the string she typed, can you find the minimum number of characters she must add to make her password strong?
         *
         * Example:
         * password = '2bb#A'
         * This password is 5 characters long and has at least one of each character type. The minimum number of characters to add is 1.
         *
         */
        const string specialCharacters = "!@#$%^&*()-+";

        var hasDigit = false;
        var hasLower = false;
        var hasUpper = false;
        var hasSpecial = false;

        for (var i = 0; i < password.Length; i++)
        {
            if (char.IsDigit(password[i]))
                hasDigit = true;

            if (char.IsLower(password[i]))
                hasLower = true;

            if (char.IsUpper(password[i]))
                hasUpper = true;

            if (specialCharacters.IndexOf(password[i]) != -1)
                hasSpecial = true;
        }

        var passedValidationsCount = Convert.ToInt32(hasDigit) +
                                     Convert.ToInt32(hasLower) +
                                     Convert.ToInt32(hasUpper) +
                                     Convert.ToInt32(hasSpecial);

        var missingValidationsCount = 4 - passedValidationsCount;
        var missingCharactersCount = 6 - password.Length;

        return Math.Max(missingValidationsCount, missingCharactersCount);
    }

    public static int[] RotateArray(int[] a, int k)
    {
        /*
            An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and 
            the last element of the array is moved to the first place. 
            For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] 
            (elements are shifted right by one index and 6 is moved to the first place).

            The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.


            k = 1
            Input  = [3, 8, 9, 7, 6] 
            Output = [6, 3, 8, 9, 7]

                0 <= N    <= 100  [0..100]
                0 <= K    <= 100  [0..100]
            -1000 <= A[i] <= 1000 [-1000..1000]
        */

        if (a.Length == 0)
            return a;

        if (k >= a.Length)
            k = k % a.Length;

        if (k == 0)
            return a;

        // Create an array of A length
        var result = new int[a.Length];

        // Loop over A
        for (var i = 0; i < a.Length; i++)
        {
            // Calculate new index
            var newIndex = i + k;

            if (newIndex >= a.Length)
                newIndex = newIndex % a.Length;

            result[newIndex] = a[i];
        }

        return result;
    }

    public static int FindUnpairedNumber_Solution1(int[] a)
    {
        // Time complexity: O(n) 
        // Space complexity: O(n) 

        /*
            1 <= N <= 1,000,000
            1 <= A[i] <= 1,000,000,000

            all but one A[i] occur an even number of times 
        */

        if (a.Length == 1)
            return a[0];

        var result = 0;
        var counts = new Dictionary<int, int>();

        // Count the occurrence of each number
        for (var i = 0; i < a.Length; i++)
        {
            if (!counts.ContainsKey(a[i]))
                counts[a[i]] = 0;

            counts[a[i]]++;
        }

        // Find the number that occurs one time
        foreach (var key in counts.Keys)
        {
            if (counts[key] == 1)
            {
                result = key;
                break;
            }
        }

        return result;
    }

    public static int FindUnpairedNumber_Solution2(int[] a)
    {
        // Time complexity: O(n) 
        // Space complexity: O(1) 

        /*
            Using XOR operator is one of the best solutions to solve the problem
            
            XOR operator:
                n XOR n = 0
                n XOR 0 = n

            So applying XOR operator to all array elements, will give us the number with single occurrence

            a = [1,2,3,3,2]
              = 1 ^ 2 ^ 3 ^ 3 ^ 2
              = 1 ^ (2 ^ 2) ^ (3 ^ 3)
              = 1 ^ 0 ^ 0
              = 1
        */

        if (a.Length == 1)
            return a[0];

        var result = a[0];

        for (var i = 1; i < a.Length; i++)
            result = result ^ a[i];

        return result;
    }

    public static int FrogJumps(int x, int y, int d)
    {
        /*
         * A small frog wants to get to the other side of the road. The frog is currently located at position X and
         * wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.
         *
         * Count the minimal number of jumps that the small frog must perform to reach its target.
         *
         * X = 10
         * Y = 85
         * D = 30
         *
         * the function should return 3
         *
         */

        /*
         * Time complexity: O(1)
         *
         * Calculate Y - X and divide the result by D.
         * Then, use Ceiling to get the smallest integer >= to the calculated decimal value
         */
        if (x == y)
            return 0;

        var jumps = (int)Math.Ceiling((decimal)(y - x) / d);

        return jumps;
    }

    public static int FindMissingInteger_Solution1(int[] a)
    {
        /*
            An array A consisting of N different integers is given. 
            The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing.
            Your goal is to find that missing element.

            - N is an integer within the range [0..100,000];
            - the elements of A are all distinct;
            - each element of array A is an integer within the range [1..(N + 1)].

            Examples:
                A = []      => 1
                A = [1]     => 2
                A = [2]     => 1
                A = [1,3,4] => 2
                A = [1,2,3] => 4
                A = [2,3,4] => 1
                A = [1,3]   => 1
        */

        // Time complexity: O(N * log(N))
        // See Solution #2 for a more efficient solution which is O(N)

        var result = 1;

        if (a.Length == 0)
            return result;

        if (a.Length == 1 && a[0] == 1)
            return result + 1;

        if (a.Length == 1 && a[0] == 2)
            return result;

        Array.Sort(a);

        for (var i = 0; i < a.Length; i++)
        {
            var curr = a[i];

            if (curr == i + 1)
            {
                result = curr + 1;
            }
            else
            {
                result = i + 1;
                break;
            }
        }

        return result;
    }

    public static int FindMissingInteger_Solution2(int[] a)
    {
        /*
            An array A consisting of N different integers is given. 
            The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing.
            Your goal is to find that missing element.

            - N is an integer within the range [0..100,000];
            - the elements of A are all distinct;
            - each element of array A is an integer within the range [1..(N + 1)].

            Examples:
                A = []      => 1
                A = [1]     => 2
                A = [2]     => 1
                A = [1,3,4] => 2
                A = [1,2,3] => 4
                A = [2,3,4] => 1
                A = [1,3]   => 1
        */

        // Time complexity: O(N)

        if (a.Length == 0)
            return 1;

        // Sum elements of array
        // Using LINQ you can do: var sum = a.Select(x => (long)x).Sum();
        // Parse to long to prevent overflow

        long sum = 0;

        for (var i = 0; i < a.Length; i++)
        {
            sum += (long)a[i];
        }

        // Sum of consecutive integers from 1 to N  = N * (N + 1) / 2
        long n = a.Length + 1;
        long totalSum = n * (n + 1) / 2;

        // The difference is the missing element
        return (int)(totalSum - sum);
    }

    #region Private Method(s)

    private static string RemoveDuplicates(string s)
    {
        var text = s.ToCharArray();

        var updated = false;

        for (var i = 0; i < text.Length - 1; i++)
        {
            var curr = text[i];
            var next = text[i + 1];

            if (curr == next)
            {
                text[i] = ' ';
                text[i + 1] = ' ';

                updated = true;
            }
        }

        var result = new string(text).Replace(" ", string.Empty);

        return updated
            ? RemoveDuplicates(result)
            : result;
    }

    #endregion
}